<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>reveal.js – The HTML Presentation Framework</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>蓝桥杯省赛冲刺</h1>
					<h3>最后七天</h3>
					<p>
						<small>Created by <a href="https://www.hfuuosc.org/">HFUU 开源社区</a></small>
					</p>
				</section>

				<section>
					<h2>特别提醒</h2>
					<p>
                        1、注意程序最后应有返回值，且返回值为0<br>
                        2、万能头文件可以使用，记得开全局空间<br>
                        3、熟悉STL用法这会给你剩下许多时间<br>
                        4、max_element、lower_bound等函数的用法请熟悉<br>
                        5、不去轻易尝试难度较高且自己没有把握的方法

					</p>
				</section>

				<!-- Example of nested vertical slides -->
				<section>
					<section>
						<h2>经典算法讲解</h2>
						<br>
						<p>不会基础算法在比赛中，会感受到异常的折磨</p>
						<br>
						<a href="#" class="navigate-down">
							<img width="178" height="238" data-src="https://s3.amazonaws.com/hakim-static/reveal-js/arrow.png" alt="Down arrow">
						</a>
                    </section>
                    <section data-markdown>
                            ## 起手式

                            ```c++
                            #include&lt;bits/stdc++.h&gt;
                            using namespace std;
                            typedef long long ll;
                            #define INF 0x3f3f3f3f
                            const int MOD = 1e9 + 7;


                            int main(){
                                freopen("input.txt","r",stdin);
                                freopen("out.txt","w",stdout);

                                return 0;
                            }
                            ```
                    </section>
                        <section data-markdown>
                                <script type="text/template">
                                    ## 1、字符串行的读取和输出

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define INF 0x3f3f3f3f
const int MOD = 1e9 + 7;


int main(){
    freopen("input.txt","r",stdin);
    //freopen("out.txt","w",stdout);
    int n;
    scanf("%d",&n);
    char a[100][100];
    for(int i=0;i<n;i++){
        getchar();
        for(int j=0;j<n;j++){
            scanf("%c",&a[i][j]);
        }
    }

    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            printf("%c",a[i][j]);
        }
        cout<<endl;
    }

    return 0;
}
```
                                </script>
                        </section>
                        <section data-markdown>
                                <script type="text/template">
                                    ## 1、字符串行的读取和输出

                                    ```c++
                                    #include<bits/stdc++.h>
                                    using namespace std;
                                    typedef long long ll;
                                    #define INF 0x3f3f3f3f
                                    const int MOD = 1e9 + 7;
                                    
                                    
                                    int main(){
                                        freopen("input.txt","r",stdin);
                                        //freopen("out.txt","w",stdout);
                                        int n;
                                        scanf("%d",&n);
                                        char a[100][100];
                                        for(int i=0;i<n;i++){
                                            getchar();
                                            for(int j=0;j<n;j++){
                                                scanf("%c",&a[i][j]);
                                            }
                                        }
                                    
                                        for(int i=0;i<n;i++){
                                            for(int j=0;j<n;j++){
                                                printf("%c",a[i][j]);
                                            }
                                            cout<<endl;
                                        }
                                    
                                        return 0;
                                    }
                                    ```  
                                </script>
                        </section>
                        <section data-markdown>
                                <script type="text/template">
                                    ## 2、memset、fill

                                    - memset在整形数组中推荐两种用法
                                    
                                    ```c++
                                    int dp[1005];
                                    memset(dp,0,sizeof(dp));//dp中的值全部置为了0
                                    memset(dp,-1,sizeof(dp));//dp中的值全部置为了-1
                                    ```
                                    
                                     有人问1,2,3其他的可行，当然是不行的，至于原因有兴趣想要知道的话，可以在网上了解
                                    
                                    - memset在char数组中
                                    
                                    ```c++
                                    char str[1005];
                                    memset(str,0,sizeof(str));
                                    ```
                                    
                                    这样就是将char数组重置了，在多组输入的情况中，memset将会是一个非常高效的方法
                                    
                                </script>
                        </section>
                        <section data-markdown>
                                <script type="text/template">
                                    ```c++
                                    int dp[100];
                                    fill(dp,dp+10,5);
                                    ```
                                    
                                    此时dp[0] -> dp[9]的值全部被置为了5
                                    
                                    ```c++
                                    char str[100];
                                    fill(str,str+10,'m');
                                    ```
                                    
                                    此时str[0] -> str[9]的值全部被置为了m
                                    
                                    
                                    
                                    以上两个例子相信大家一下子就对fill有所了解了吧，在实际运用中大家可以根据自己的需要使用fill和memset    
                                </script>
                        </section>
                        
            </section>
            <section data-markdown>
                    <script type="text/template">
                        ## 3、gcd、lcm

                        ```c++
                        int gcd(int a,int b){
                            return b == 0 ? a : gcd(b,a%b);
                        } 
                        
                        int lcm(int a,int b){
                            return a*b/gcd(a,b);
                        }
                        ```  
                    </script>
            </section>
            <section>
            <section data-markdown>
                    <script type="text/template">
                        ## 4、字符串函数

                        - 字符处理函数：ctype.h
                        
                        ```
                        int isdigit(int ch)  ;//是否为数字，即ch是否是0-9中的字符
                        int isxdigit(int ch) ;//是否为十六进制数字，即ch是否是0-9 a-z A-Z中的字符
                        int isalpha(int ch)  ;//是否为字母
                        int isalnum(int ch)  ;//是否为字母或数字
                        int islower(int ch)  ;//是否为小写字母
                        int isupper(int ch)  ;//是否为大写字母
                        int tolower(int ch)  ;//转换为小写字母
                        int toupper(int ch)  ;//转换为大写字母
                        ``` 
                    </script>
            </section>
            <section data-markdown>
                    <script type="text/template">
                        - 字符串转换函数：stdlib.h

                        **字符转换为数字：**
                        
                        ```
                        double atof(char  *str) ; //将字符串str转换为double型数字
                        int    atoi (char  *str) ; //将字符串str转换为int 型数字
                        long   atol(char  *str) ; //将字符串str转换为long int 型数字
                        ```
                        
                        **数字转换为字符：**
                        
                        ```
                        //将int型数字digit按radix进制转换成字符串destStr
                        char * itoa (int digit, char *destStr, int radix) ;
                        //同理将long型数字转换成字符串
                        char * ltoa (long digit, char *destStr, int radix) ;
                        //同理将unsignedlong型数字转换成字符串
                        char * ultoa (long digit, char *destStr,int radix) ;
                        ```
                        
                        【以上库函数能够用于进制的转换】 
                    </script>
            </section>
            <section data-markdown>
                    <script type="text/template">
                        - 字符串操作函数：string.h

                        ```
                        char * strcpy (char *s1, char *s2) ; //将字符串s2拷贝到数组s1中。
                        char * strncpy(char *s1,char *s2) ; //将字符串s2的最多n个字符拷贝到数组s1中
                        char * strcat (char *s1, char * s2) ; //将字符串s2连接在字符串s1尾部
                        char * strncat(char *s1, char *s2, size_tn) ; //将字符串s2中最多n个字符连接在s1之后
                        ```
                        
                        【注意：以上操作都要求目标字符数组有足够的存储空间】
                    </script>
            </section>
            <section data-markdown>
                    <script type="text/template">
                        - 字符串查找函数：string.h

                        ```
                        //在字符串str中查找字符ch第一次出现的位置，假设找到了，就返回str中ch的指针，否则返回NULL
                        char *strchr(char*str, int ch) ;
                        //查找字符串str中字符ch的最后一次出现的位置(即：从后往前查找)
                        char*strrchr(char *str, int ch) ;
                        //查找字符串str1中第一次出现字符串str2的位置
                        char *strstr(char*str1, char *str2) ;
                        //查找字符串str2中随意字符在字符串str1中首次出现的位置。
                        char*strpbrk(char *str1, char *str2)
                        ```
                    </script>
            </section>
            <section data-markdown>
                    <script type="text/template">
                        其他函数：

                        ```
                        char *strrev(char * ) ; //字符串逆序函数
                        size_t strlen(char * str) ;//測字符串str的长度
                        
                        ```
                        
                        注意<br>
                        strncpy( ),strncat( ),strncmp( ),这些函数仅能对不同的字符串操作，不能对同一字符串的不同部分操作。<br>  
                        若把目标字符串初始置空，strncat()能够完毕非常多功能的操作。能够替代strncpy( )的功能，还能够提取子串等。
                    </script>
            </section>
            </section>
            <section>
            <section data-markdown>
                    <script type="text/template">
                        ## 5、素数系列

                        - 埃拉托斯特尼筛法，或者叫埃氏筛法
                        
                        ```c++
                        const int N = 100005;  
                        bool prime[N];  
                        void init(){  
                            for(int i=2;i<N;i++) prime[i]=true;//先全部初始化为素数  
                            for(int i=2;i*i<N;i++){  
                                if(prime[i]){//如果i是质数  
                                    for(int j=i*i;j<N;j+=i){//从i的两倍开始的所有的倍数(i*i也行)  
                                        prime[j] = false;  
                                    }  
                                }  
                            }  
                        }  
                        ``` 
                    </script>
            </section>
            <section data-markdown>
                    <script type="text/template">
                        - 预处理每个数的所有质因数

                        ```c++
                        const int N = 100000 + 5;  
                        vector<int > prime_factor[N];  
                        void init(){  
                            for(int i = 2; i < N; i ++){  
                                if(prime_factor[i].size() == 0){//如果i是质数   
                                    for(int j = i; j < N; j += i){  
                                        prime_factor[j].push_back(i);   
                                    }  
                                }  
                            }  
                        } 
                        ``` 
                    </script>
            </section>
            <section data-markdown>
                    <script type="text/template">
                        - 比如预处理每个数的所有因数

                        ```c++
                        const int N = 100000 + 5;  
                        vector<int > factor[N];  
                        void init(){  
                            for(int i = 2; i < N; i ++){  
                                for(int j = i; j < N; j += i){  
                                    factor[j].push_back(i);  
                                }  
                            }  
                        }
                        ``` 
                    </script>
            </section>
            <section data-markdown>
                    <script type="text/template">
                        - 预处理每个数的质因数分解

                        ```c++
                        const int N = 100000 + 5;  
                        vector<int > prime_factor[N];  
                        void init(){  
                            int temp;  
                            for(int i = 2; i < N; i ++){  
                                if(prime_factor[i].size() == 0){  
                                    for(int j = i; j < N; j += i){  
                                        temp = j;  
                                        while(temp % i == 0){  
                                            prime_factor[j].push_back(i);  
                                            temp /= i;  
                                        }  
                                    }  
                                }  
                            }  
                        }
                        ``` 
                    </script>
            </section>
            <section data-markdown>
                    <script type="text/template">
                        http://blog.csdn.net/laichilizi/article/details/79390020

                        质因数分解题目↑（输入两个整数a、b，每行输出一个数的分解，形如k=a1*a2*a3...(a1<=a2<=a3....）
                        
                        ```c++
                        #include<bits/stdc++.h>    
                        using namespace std;    
                        const int N = 100000 + 5;    
                        vector<int > prime_factor[N];    
                        void init(){    
                            int temp;    
                            for(int i = 2; i < N; i ++){    
                                if(prime_factor[i].size() == 0){    
                                    for(int j = i; j < N; j += i){    
                                        temp = j;    
                                        while(temp % i == 0){    
                                            prime_factor[j].push_back(i);    
                                            temp /= i;    
                                        }    
                                    }    
                                }    
                            }    
                        }    
                        int main()  
                        {    
                            init();   
                              
                            int a,b;  
                            scanf("%d %d",&a,&b);  
                            vector<int>::iterator it;  
                            for(int i=a;i<=b;i++){  
                                cout<<i<<"=";  
                                for(it = prime_factor[i].begin(); it != prime_factor[i].end(); it++){  
                                    if(it != prime_factor[i].end()-1) cout << *it <<"*";  
                                    else cout<<*it<<endl;  
                                }  
                                      
                            }   
                        }  
                        ``` 
                    </script>
            </section>
        </section>
        <section>
            <section data-markdown>
                    <script type="text/template">
                        ## 6、斐波那契数列

                        采用记忆化搜索的写法，或者使用状态转移的方法推导
                        
                        - 记忆化搜索写法
                        
                        ```c++
                        int dp[1005];
                        int dfs(int n){
                            if(n==1 || n==2){
                                return 1;
                            }
                            if(dp[n] > 0){
                                return dp[n];
                            }else{
                                dp[n] = dfs(n-1) + dfs(n-2);
                                return dp[n];
                            }	
                        }
                        
                        ```
                        
                       
                    </script>
            </section>
            <section data-markdown>
                    <script type="text/template">
                        - 状态转移写法
                        
                        ```c++
                        int dp[1000];
                        dp[1] = 1;
                        dp[2] = 1;
                        for(int i=3;i<1000;i++){
                          dp[i] = dp[i-1] + dp[i-2];
                        } 
                        ```  
                    </script>
            </section>
        </section>
            <section data-markdown>
                    <script type="text/template">
                        ## 7、快速幂

                        - 快速幂
                        
                        ```c++
                        typedef long long ll;
                        ll ksm(ll x,ll n,ll mod){
                            ll res = 1;
                            x = x % mod;
                            while(x > 0){
                                if(n & 1) res = res * x % mod;
                                x = x * x % mod;
                                n >>= 1;
                            }
                            return res;
                        }
                        ``` 
                    </script>
            </section>
            <section data-markdown>
                    <script type="text/template">
                        ## 8、BFS系列

                        http://blog.csdn.net/laichilizi/article/details/75024841
                        
                        - 马的移动↑，BFS入门题
                        
                        http://blog.csdn.net/laichilizi/article/details/79383954
                        
                        - 学霸的迷宫↑，BFS+记录操作方向 
                    </script>
            </section>
            <section data-markdown>
                    <script type="text/template">
                        ## 9、DFS系列

                        http://blog.csdn.net/laichilizi/article/details/79388913
                        
                        - 正则问题↑，一个由x()|组成的正则表达式。输入长度不超过100，保证合法，求这个正则表达式能接受的最长字符串的长度
                        
                        http://blog.csdn.net/laichilizi/article/details/78714582
                        
                        - POJ-2386，简单区域连通问题，↑ 
                    </script>
            </section>
            <section data-markdown>
                    <script type="text/template">
                        ## 10、二分搜索

                        二分模型
                        
                        ```c++
                        while(l < r-1){
                                int mid = r + (l - r)>> 1;
                                if() l = mid;
                                else r = mid;
                            }
                        ```
                        
                        http://blog.csdn.net/laichilizi/article/details/79388555
                        
                        - 分巧克力↑，经典二分题  
                    </script>
            </section>
            <section>
            <section data-markdown>
                    <script type="text/template">
                        ## 11、动态规划（01背包，完全背包）
                        - 01背包（一维最简化）

                        ```c++
                        int dp[MAX_W +1];
                        
                        void solve(){
                            for(int i=0;i<n;i++){
                                for(int j=W;j>=w[i];j--){
                                    dp[j] = max(dp[j],dp[j-w[i]]+v[i]);
                                }
                            }
                            printf("%d\n",dp[W]);
                        }
                        ```
                       
                    </script>
            </section>
            <section data-markdown>
                    <script type="text/template">
                      
                        - 完全背包（一维最简化）
                        
                        ```c++
                        int dp[MAX_W +1];
                        
                        void solve(){
                            for(int i=0;i<n;i++){
                                for(int j=w[i];j<=W;j--){
                                    dp[j] = max(dp[j],dp[j-w[i]]+v[i]);
                                }
                            }
                            printf("%d\n",dp[W]);
                        }
                        ```  
                    </script>
            </section>
        </section>
            <section data-markdown>
                    <script type="text/template">
                      
                        除了LCS的数目，还输出对应的子串

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

char a[1005],b[1005],ans[1005];
int dp[1005][1005];
int main()
{
	//freopen("input.txt","r",stdin);

	scanf("%s %s",a+1,b+1);
	int n = strlen(a+1);
	int m = strlen(b+1);
	memset(dp,0,sizeof(dp));

	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i] == b[j]){
				dp[i][j] = dp[i-1][j-1] + 1;
			}else{
				dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
			}
		}
	}
	int cur = 0;
	for(int i=n,j=m;dp[i][j];--i,--j){
		while(dp[i][j] == dp[i-1][j]) --i;
		while(dp[i][j] == dp[i][j-1]) --j;
		ans[cur++] = a[i];
	}

	reverse(ans,ans+cur);
	//ans[cur] = '\0';
	printf("%s\n",ans);

	return 0;
}
``` 
                    </script>
            </section>
            <section data-markdown>
                    <script type="text/template">
                        ## 13、LIS

                        ```c++
                        #include<bits/stdc++.h>  
                        using namespace std;  
                        #define INF 0x3f3f3f3f  
                        typedef long long ll;  
                          
                        int dp[105];  
                        int a[105];  
                          
                        int main()  
                        {  
                            int n;  
                            scanf("%d",&n);  
                            for(int i=0;i<n;i++) scanf("%d",&a[i]);  
                              
                            int res = 0;  
                            for(int i=0;i<n;i++){  
                                dp[i] = 1;  
                                for(int j=0;j<i;j++){  
                                    if(a[j] < a[i]){ //如果是包括相等，就改为<=   
                                        dp[i] = max(dp[i],dp[j]+1);  
                                    }  
                                }  
                                res = max(res,dp[i]);   
                            }  
                            cout<<res<<endl;  
                          
                            return 0;  
                        }
                        ```  
                    </script>
            </section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/search/search.js', async: true },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
